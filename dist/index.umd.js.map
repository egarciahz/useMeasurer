{"version":3,"file":"index.umd.js","sources":["../src/useMeasurer.ts","../src/getNodeRect.ts"],"sourcesContent":["import { useEffect, useState, useRef, useCallback, RefObject } from 'react';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport useInstance from '@use-it/instance/dist/instance';\nimport { MeasuringOptions, Dimensions } from \"./interfaces\";\nimport getNodeRect from \"./getNodeRect\";\n\ntype Measurer = () => void;\n\nfunction useMeasurer<T extends MeasuringOptions>(options: T[]): [{ [K in T]: Dimensions[K] }, RefObject<HTMLElement>, Measurer] {\n    console.log('pass function ')\n    const self = useInstance({});\n    console.log('pass useInstance')\n\n    const [mesure, setMeasure] = useState<any>({});\n    console.log(\"pass useState\")\n\n    const node = useRef<HTMLElement>(null);\n    console.log(\"pass useRef\")\n    const measurer = useCallback<Measurer>(() => {\n        if (node.current) {\n            const measured = getNodeRect(node.current, options);\n            self.animFrameID = window.requestAnimationFrame(() => {\n                setMeasure(measured);\n            });\n        }\n    }, [node.current]);\n\n    var observer: ResizeObserver | null = useInstance(new ResizeObserver(measurer));\n\n    useEffect(() => {\n        if (node.current && observer) {\n            observer.unobserve(node.current);\n            observer.observe(node.current);\n        }\n\n        return () => {\n            window.cancelAnimationFrame(self.animFrameID);\n            if (observer) {\n                observer.disconnect();\n                observer = null;\n            }\n        }\n    }, [node.current]);\n\n    return [mesure, node, measurer];\n}\n\nexport default useMeasurer;\n","import { MeasuringOptions, Dimensions } from \"./interfaces\";\n\nfunction getNodeRect(node: HTMLElement, types: MeasuringOptions[]): Dimensions {\n    const calculations: Dimensions = {}\n\n    if (types.indexOf('client') > -1) {\n        calculations.client = {\n            top: node.clientTop,\n            left: node.clientLeft,\n            width: node.clientWidth,\n            height: node.clientHeight,\n        }\n    }\n\n    if (types.indexOf('offset') > -1) {\n        calculations.offset = {\n            top: node.offsetTop,\n            left: node.offsetLeft,\n            width: node.offsetWidth,\n            height: node.offsetHeight,\n        }\n    }\n\n    if (types.indexOf('scroll') > -1) {\n        calculations.scroll = {\n            top: node.scrollTop,\n            left: node.scrollLeft,\n            width: node.scrollWidth,\n            height: node.scrollHeight,\n        }\n    }\n\n    if (types.indexOf('bounds') > -1) {\n        const rect = node.getBoundingClientRect()\n        calculations.bounds = {\n            top: rect.top,\n            right: rect.right,\n            bottom: rect.bottom,\n            left: rect.left,\n            width: rect.width,\n            height: rect.height,\n        }\n    }\n\n    if (types.indexOf('margin') > -1) {\n        const styles = getComputedStyle(node)\n        calculations.margin = {\n            top: styles ? parseInt(styles.marginTop) : 0,\n            right: styles ? parseInt(styles.marginRight) : 0,\n            bottom: styles ? parseInt(styles.marginBottom) : 0,\n            left: styles ? parseInt(styles.marginLeft) : 0,\n        }\n    }\n\n    return calculations\n}\n\nexport default getNodeRect;\n"],"names":["options","console","log","self","useInstance","useState","node","useRef","measurer","useCallback","current","measured","types","calculations","indexOf","client","top","clientTop","left","clientLeft","width","clientWidth","height","clientHeight","offset","offsetTop","offsetLeft","offsetWidth","offsetHeight","scroll","scrollTop","scrollLeft","scrollWidth","scrollHeight","rect","getBoundingClientRect","bounds","right","bottom","styles","getComputedStyle","margin","parseInt","marginTop","marginRight","marginBottom","marginLeft","getNodeRect","animFrameID","window","requestAnimationFrame","setMeasure","observer","ResizeObserver","useEffect","unobserve","observe","cancelAnimationFrame","disconnect","mesure"],"mappings":"0dAQA,SAAiDA,GAC7CC,QAAQC,IAAI,sBACNC,EAAOC,EAAY,IACzBH,QAAQC,IAAI,0BAEiBG,WAAc,kBAC3CJ,QAAQC,IAAI,qBAENI,EAAOC,SAAoB,MACjCN,QAAQC,IAAI,mBACNM,EAAWC,4BACTH,EAAKI,QAAS,KACRC,EClBlB,SAAqBL,EAAmBM,OAC9BC,EAA2B,MAE7BD,EAAME,QAAQ,WAAa,IAC3BD,EAAaE,OAAS,CAClBC,IAAKV,EAAKW,UACVC,KAAMZ,EAAKa,WACXC,MAAOd,EAAKe,YACZC,OAAQhB,EAAKiB,eAIjBX,EAAME,QAAQ,WAAa,IAC3BD,EAAaW,OAAS,CAClBR,IAAKV,EAAKmB,UACVP,KAAMZ,EAAKoB,WACXN,MAAOd,EAAKqB,YACZL,OAAQhB,EAAKsB,eAIjBhB,EAAME,QAAQ,WAAa,IAC3BD,EAAagB,OAAS,CAClBb,IAAKV,EAAKwB,UACVZ,KAAMZ,EAAKyB,WACXX,MAAOd,EAAK0B,YACZV,OAAQhB,EAAK2B,eAIjBrB,EAAME,QAAQ,WAAa,EAAG,KACxBoB,EAAO5B,EAAK6B,wBAClBtB,EAAauB,OAAS,CAClBpB,IAAKkB,EAAKlB,IACVqB,MAAOH,EAAKG,MACZC,OAAQJ,EAAKI,OACbpB,KAAMgB,EAAKhB,KACXE,MAAOc,EAAKd,MACZE,OAAQY,EAAKZ,WAIjBV,EAAME,QAAQ,WAAa,EAAG,KACxByB,EAASC,iBAAiBlC,GAChCO,EAAa4B,OAAS,CAClBzB,IAAKuB,EAASG,SAASH,EAAOI,WAAa,EAC3CN,MAAOE,EAASG,SAASH,EAAOK,aAAe,EAC/CN,OAAQC,EAASG,SAASH,EAAOM,cAAgB,EACjD3B,KAAMqB,EAASG,SAASH,EAAOO,YAAc,UAI9CjC,EDlCkBkC,CAAYzC,EAAKI,QAASV,GAC3CG,EAAK6C,YAAcC,OAAOC,iCACtBC,EAAWxC,OAGpB,CAACL,EAAKI,UAEL0C,EAAkChD,EAAY,IAAIiD,EAAe7C,WAErE8C,8BACQhD,EAAKI,SAAW0C,IAChBA,EAASG,UAAUjD,EAAKI,SACxB0C,EAASI,QAAQlD,EAAKI,qBAItBuC,OAAOQ,qBAAqBtD,EAAK6C,aAC7BI,IACAA,EAASM,aACTN,EAAW,QAGpB,CAAC9C,EAAKI,UAEF,CAACiD,EAAQrD,EAAME"}